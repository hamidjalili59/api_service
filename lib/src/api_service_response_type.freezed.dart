// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'api_service_response_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ApiServiceResponseType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? json,
    TResult? Function()? stream,
    TResult? Function()? plain,
    TResult? Function()? bytes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Json value)? json,
    TResult? Function(_Stream value)? stream,
    TResult? Function(_Plain value)? plain,
    TResult? Function(_Bytes value)? bytes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiServiceResponseTypeCopyWith<$Res> {
  factory $ApiServiceResponseTypeCopyWith(ApiServiceResponseType value,
          $Res Function(ApiServiceResponseType) then) =
      _$ApiServiceResponseTypeCopyWithImpl<$Res, ApiServiceResponseType>;
}

/// @nodoc
class _$ApiServiceResponseTypeCopyWithImpl<$Res,
        $Val extends ApiServiceResponseType>
    implements $ApiServiceResponseTypeCopyWith<$Res> {
  _$ApiServiceResponseTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ApiServiceResponseType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$JsonImplCopyWith<$Res> {
  factory _$$JsonImplCopyWith(
          _$JsonImpl value, $Res Function(_$JsonImpl) then) =
      __$$JsonImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$JsonImplCopyWithImpl<$Res>
    extends _$ApiServiceResponseTypeCopyWithImpl<$Res, _$JsonImpl>
    implements _$$JsonImplCopyWith<$Res> {
  __$$JsonImplCopyWithImpl(_$JsonImpl _value, $Res Function(_$JsonImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiServiceResponseType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$JsonImpl implements _Json {
  const _$JsonImpl();

  @override
  String toString() {
    return 'ApiServiceResponseType.json()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$JsonImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) {
    return json();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? json,
    TResult? Function()? stream,
    TResult? Function()? plain,
    TResult? Function()? bytes,
  }) {
    return json?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) {
    if (json != null) {
      return json();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) {
    return json(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Json value)? json,
    TResult? Function(_Stream value)? stream,
    TResult? Function(_Plain value)? plain,
    TResult? Function(_Bytes value)? bytes,
  }) {
    return json?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (json != null) {
      return json(this);
    }
    return orElse();
  }
}

abstract class _Json implements ApiServiceResponseType {
  const factory _Json() = _$JsonImpl;
}

/// @nodoc
abstract class _$$StreamImplCopyWith<$Res> {
  factory _$$StreamImplCopyWith(
          _$StreamImpl value, $Res Function(_$StreamImpl) then) =
      __$$StreamImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StreamImplCopyWithImpl<$Res>
    extends _$ApiServiceResponseTypeCopyWithImpl<$Res, _$StreamImpl>
    implements _$$StreamImplCopyWith<$Res> {
  __$$StreamImplCopyWithImpl(
      _$StreamImpl _value, $Res Function(_$StreamImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiServiceResponseType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StreamImpl implements _Stream {
  const _$StreamImpl();

  @override
  String toString() {
    return 'ApiServiceResponseType.stream()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StreamImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) {
    return stream();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? json,
    TResult? Function()? stream,
    TResult? Function()? plain,
    TResult? Function()? bytes,
  }) {
    return stream?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) {
    if (stream != null) {
      return stream();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) {
    return stream(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Json value)? json,
    TResult? Function(_Stream value)? stream,
    TResult? Function(_Plain value)? plain,
    TResult? Function(_Bytes value)? bytes,
  }) {
    return stream?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (stream != null) {
      return stream(this);
    }
    return orElse();
  }
}

abstract class _Stream implements ApiServiceResponseType {
  const factory _Stream() = _$StreamImpl;
}

/// @nodoc
abstract class _$$PlainImplCopyWith<$Res> {
  factory _$$PlainImplCopyWith(
          _$PlainImpl value, $Res Function(_$PlainImpl) then) =
      __$$PlainImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PlainImplCopyWithImpl<$Res>
    extends _$ApiServiceResponseTypeCopyWithImpl<$Res, _$PlainImpl>
    implements _$$PlainImplCopyWith<$Res> {
  __$$PlainImplCopyWithImpl(
      _$PlainImpl _value, $Res Function(_$PlainImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiServiceResponseType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$PlainImpl implements _Plain {
  const _$PlainImpl();

  @override
  String toString() {
    return 'ApiServiceResponseType.plain()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PlainImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) {
    return plain();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? json,
    TResult? Function()? stream,
    TResult? Function()? plain,
    TResult? Function()? bytes,
  }) {
    return plain?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) {
    if (plain != null) {
      return plain();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) {
    return plain(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Json value)? json,
    TResult? Function(_Stream value)? stream,
    TResult? Function(_Plain value)? plain,
    TResult? Function(_Bytes value)? bytes,
  }) {
    return plain?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (plain != null) {
      return plain(this);
    }
    return orElse();
  }
}

abstract class _Plain implements ApiServiceResponseType {
  const factory _Plain() = _$PlainImpl;
}

/// @nodoc
abstract class _$$BytesImplCopyWith<$Res> {
  factory _$$BytesImplCopyWith(
          _$BytesImpl value, $Res Function(_$BytesImpl) then) =
      __$$BytesImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BytesImplCopyWithImpl<$Res>
    extends _$ApiServiceResponseTypeCopyWithImpl<$Res, _$BytesImpl>
    implements _$$BytesImplCopyWith<$Res> {
  __$$BytesImplCopyWithImpl(
      _$BytesImpl _value, $Res Function(_$BytesImpl) _then)
      : super(_value, _then);

  /// Create a copy of ApiServiceResponseType
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BytesImpl implements _Bytes {
  const _$BytesImpl();

  @override
  String toString() {
    return 'ApiServiceResponseType.bytes()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BytesImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) {
    return bytes();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? json,
    TResult? Function()? stream,
    TResult? Function()? plain,
    TResult? Function()? bytes,
  }) {
    return bytes?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) {
    return bytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Json value)? json,
    TResult? Function(_Stream value)? stream,
    TResult? Function(_Plain value)? plain,
    TResult? Function(_Bytes value)? bytes,
  }) {
    return bytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(this);
    }
    return orElse();
  }
}

abstract class _Bytes implements ApiServiceResponseType {
  const factory _Bytes() = _$BytesImpl;
}
