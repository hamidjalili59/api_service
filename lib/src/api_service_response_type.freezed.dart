// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'api_service_response_type.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ApiServiceResponseType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApiServiceResponseTypeCopyWith<$Res> {
  factory $ApiServiceResponseTypeCopyWith(ApiServiceResponseType value,
          $Res Function(ApiServiceResponseType) then) =
      _$ApiServiceResponseTypeCopyWithImpl<$Res>;
}

/// @nodoc
class _$ApiServiceResponseTypeCopyWithImpl<$Res>
    implements $ApiServiceResponseTypeCopyWith<$Res> {
  _$ApiServiceResponseTypeCopyWithImpl(this._value, this._then);

  final ApiServiceResponseType _value;
  // ignore: unused_field
  final $Res Function(ApiServiceResponseType) _then;
}

/// @nodoc
abstract class _$$_JsonCopyWith<$Res> {
  factory _$$_JsonCopyWith(_$_Json value, $Res Function(_$_Json) then) =
      __$$_JsonCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_JsonCopyWithImpl<$Res>
    extends _$ApiServiceResponseTypeCopyWithImpl<$Res>
    implements _$$_JsonCopyWith<$Res> {
  __$$_JsonCopyWithImpl(_$_Json _value, $Res Function(_$_Json) _then)
      : super(_value, (v) => _then(v as _$_Json));

  @override
  _$_Json get _value => super._value as _$_Json;
}

/// @nodoc

class _$_Json implements _Json {
  const _$_Json();

  @override
  String toString() {
    return 'ApiServiceResponseType.json()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Json);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) {
    return json();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
  }) {
    return json?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) {
    if (json != null) {
      return json();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) {
    return json(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
  }) {
    return json?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (json != null) {
      return json(this);
    }
    return orElse();
  }
}

abstract class _Json implements ApiServiceResponseType {
  const factory _Json() = _$_Json;
}

/// @nodoc
abstract class _$$_StreamCopyWith<$Res> {
  factory _$$_StreamCopyWith(_$_Stream value, $Res Function(_$_Stream) then) =
      __$$_StreamCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StreamCopyWithImpl<$Res>
    extends _$ApiServiceResponseTypeCopyWithImpl<$Res>
    implements _$$_StreamCopyWith<$Res> {
  __$$_StreamCopyWithImpl(_$_Stream _value, $Res Function(_$_Stream) _then)
      : super(_value, (v) => _then(v as _$_Stream));

  @override
  _$_Stream get _value => super._value as _$_Stream;
}

/// @nodoc

class _$_Stream implements _Stream {
  const _$_Stream();

  @override
  String toString() {
    return 'ApiServiceResponseType.stream()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Stream);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) {
    return stream();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
  }) {
    return stream?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) {
    if (stream != null) {
      return stream();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) {
    return stream(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
  }) {
    return stream?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (stream != null) {
      return stream(this);
    }
    return orElse();
  }
}

abstract class _Stream implements ApiServiceResponseType {
  const factory _Stream() = _$_Stream;
}

/// @nodoc
abstract class _$$_PlainCopyWith<$Res> {
  factory _$$_PlainCopyWith(_$_Plain value, $Res Function(_$_Plain) then) =
      __$$_PlainCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PlainCopyWithImpl<$Res>
    extends _$ApiServiceResponseTypeCopyWithImpl<$Res>
    implements _$$_PlainCopyWith<$Res> {
  __$$_PlainCopyWithImpl(_$_Plain _value, $Res Function(_$_Plain) _then)
      : super(_value, (v) => _then(v as _$_Plain));

  @override
  _$_Plain get _value => super._value as _$_Plain;
}

/// @nodoc

class _$_Plain implements _Plain {
  const _$_Plain();

  @override
  String toString() {
    return 'ApiServiceResponseType.plain()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Plain);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) {
    return plain();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
  }) {
    return plain?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) {
    if (plain != null) {
      return plain();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) {
    return plain(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
  }) {
    return plain?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (plain != null) {
      return plain(this);
    }
    return orElse();
  }
}

abstract class _Plain implements ApiServiceResponseType {
  const factory _Plain() = _$_Plain;
}

/// @nodoc
abstract class _$$_BytesCopyWith<$Res> {
  factory _$$_BytesCopyWith(_$_Bytes value, $Res Function(_$_Bytes) then) =
      __$$_BytesCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_BytesCopyWithImpl<$Res>
    extends _$ApiServiceResponseTypeCopyWithImpl<$Res>
    implements _$$_BytesCopyWith<$Res> {
  __$$_BytesCopyWithImpl(_$_Bytes _value, $Res Function(_$_Bytes) _then)
      : super(_value, (v) => _then(v as _$_Bytes));

  @override
  _$_Bytes get _value => super._value as _$_Bytes;
}

/// @nodoc

class _$_Bytes implements _Bytes {
  const _$_Bytes();

  @override
  String toString() {
    return 'ApiServiceResponseType.bytes()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Bytes);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() json,
    required TResult Function() stream,
    required TResult Function() plain,
    required TResult Function() bytes,
  }) {
    return bytes();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
  }) {
    return bytes?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? json,
    TResult Function()? stream,
    TResult Function()? plain,
    TResult Function()? bytes,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Json value) json,
    required TResult Function(_Stream value) stream,
    required TResult Function(_Plain value) plain,
    required TResult Function(_Bytes value) bytes,
  }) {
    return bytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
  }) {
    return bytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Json value)? json,
    TResult Function(_Stream value)? stream,
    TResult Function(_Plain value)? plain,
    TResult Function(_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(this);
    }
    return orElse();
  }
}

abstract class _Bytes implements ApiServiceResponseType {
  const factory _Bytes() = _$_Bytes;
}
